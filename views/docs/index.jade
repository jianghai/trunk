extends ../layout
block head
  link(rel='stylesheet', href='/stylesheets/docs/index.css')
block main
  .sidebar
    ul
      li
        a(href='#overview') Overview
      li
        a.class(href='#view') Trunk.View
        ul
          li
            a.property(href='#view-events') events
          li
            a.events(href='#') events
          li
            a.static(href='#') extend
          li
            a.method(href='#') render
          li
            a.method(href='#') render
          
      li
        a(href='#') Trunk.Model
        ul
          li
            a(href='#') render
          li
            a(href='#') render
          li
            a(href='#') render
      li
        a(href='#') Trunk.Collection
        ul
          li
            a(href='#') render
          li
            a(href='#') render
          li
            a(href='#') render
      li
        a(href='#') Events
        ul
          li
            a.method(href='#') listen
          li
            a.method(href='#') listenOnce
          li
            a.method(href='#') on
          li
            a.method(href='#') once
          li
            a.method(href='#') off
          li
            a.method(href='#') trigger
  .content.flex-1
    section#overview 
      h1 Overview
      p Trunk.js把前端开发划分成view（页面最终呈现，事件交互）、model（view背后逻辑、数据处理）和collection(模型集合)，view和model一一对应作为一个微观世界。view因业务需求可能变得很复杂，所以支持嵌套，即一个微观世界里可能囊括多个微观世界。随着越来越多的微观世界产生，那些通用的逻辑、操作、现象就可以抽象出一个抽象的世界（本身也可能是nested）。到最后，前端开发就像搭积木一样简单而又清晰。
      include ../include/structure.svg
      //- p 当你处理一些业务逻辑，用jQuery选择元素绑定事件写一堆面条式代码变得混乱不清时；当你ajax获取json数据拼装繁杂的html时；
      
      p 如上图，一一对应的view和model构成了一个组件（component），组件的最大作用就是提高代码的可复用性，组件本身可以直接实例化或者被其他view、model继承（严格意义上Trunk.View和Trunk.Model是一个最基础的组件）。

      p 跨模块通信由事件驱动，典型的观察者模式。
      pre
        :highlight(lang='js')
          // Register event
          view1.listen(model2, 'save', function() {
            // Do something
          });
          // Fire event
          model2.trigger('save');
    section#view

      h1.class Trunk.View
      p view主要定义页面事件交互、响应model事件等等。
      pre
        :highlight(lang='js')
          var app = new Trunk.View();
      
      h2.property el
      p 非动态创建的view根元素节点，支持jQuery元素、#id，如果是 <a href="#view-children">children</a> 场景，则使用selectors语法。 children场景下el元素只会在父view渲染后（render:after事件）再绑定el对象。
      pre
        :highlight(lang='js')
          var app = new Trunk.View({
            el: '#app'
          });

      h2.property tag
      p 动态创建的view根元素tagName。
      pre
        :highlight(lang='js')
          var item = new Trunk.View({
            tag: 'li'
          });
          $('ul').append(item.el);
      
      h2.property template
      p view渲染不再是繁杂的HTML拼装，而是基于字符串的模版模式，目前依赖 <a href="http://github.com/jianghai/vjs" target="_blank">vjs</a> ，实际使用时先在HTML中添加模板（模板定义时不包括el元素本身）。
      pre
        :highlight(lang='markup')
          <script id="template-list-item" type="text">
          <h1><#- data.message #><h1>
          </script>
      p 指定模版script元素选择器（class或者id），id的话则从整个DOM中获取，class则从当前view根元素下获取，当el准备好（存在于DOM中）就会获取模板，此时请确保模版存在于DOM中。
      pre
        :highlight(lang='js')
          var item = new Trunk.View({
            tag: 'li',
            template: '#template-list-item'
          });
      p 执行 <a href="#view-render">render</a> 时会把model的 <a href="#model-data">data</a> 属性值传到模版作用域中。
      
      h2#view-events.property events
      p 传统的事件绑定比较分散，不容易统一管理和维护，这里定义了events属性，所有的事件以key:value的形式统一定义，handle的参数与jQuery定义的的相同，只是this指向了当前的view对象。所有事件都是绑定在当前view根元素节点上的，支持事件委托（'event selector': 'handle'）。
      pre
        :highlight(lang='js')
          var app = new Trunk.View({
            events: {
              'click': 'onClick',
              'change select': 'onChange' // Event delegation
            },
            onClick: function(e) {},
            onChange: function(e) {}
          });

      h2.method init
      p 实例化时执行的函数，执行前所有定义的属性和方法均已关联到当前view对象中。
      pre
        :highlight(lang='js')
          var app = new Trunk.View({
            say: function() {
              console.log('Hello world!');
            },
            init: function() {
              this.say(); // Hello world!
            }
          });

      h2.method $
      p 选择器（当前view中）。
      pre
        :highlight(lang='js')
          var app = new Trunk.View({
            init: function() {
              this.$('.list'); // Equal to this.el.find('.list')
            }
          });

      h2.method render
      p view渲染，默认将模版输出的html添加到el元素中，model执行 <a href="#model-reset">reset</a> 后会执行render。两个事件 <a href="#view-events-render:before">render:before</a> 和 <a href="#view-events-render:after">render:after</a> ，如果有children views，则继续渲染children。
      p 一般很少需要重写，除非不依赖模版，如使用highcharts或者d3渲染。
      pre
        :highlight(lang='js')
          var app = new Trunk.View({
            render: function() {
              new Highcharts.Chart({
                renderTo: this.el[0]
              });
            }
          });

      h2.property children
      p 

      h2.property className
      p 根元素className。如果el元素已经有className，则追加。
      pre
        :highlight(lang='js')
          var item = new Trunk.View({
            tag: 'li',
            className: 'list-item'
          });
          // After render: <li className="list-item"></li>
        
